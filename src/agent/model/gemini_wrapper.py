import os
import sys
import time
from google import genai
from google.genai import types
from src.agent.model.model import Model, PredictConfig
from src.utils.logger_config import logger, COLOR_CODES, RESET

class GeminiWrapper(Model):
    def __init__(self, name):
        super().__init__(name=name)
        self.api_key = os.environ.get("GEMINI_API_KEY")
        if not self.api_key:
            raise ValueError("GEMINI_API_KEY environment variable is required")
        
        self.is_chat_model = True
        self.client = genai.Client(api_key=self.api_key)
        self.cache = None
    
    def init_cache(self, system_prompt: str):
        self.cache = self.client.caches.create(
            model=self.name,
            config=types.CreateCachedContentConfig(
                system_instruction=system_prompt,
            )
        )
        print(f'{self.cache=}')
    
    def predict(self, config: PredictConfig) -> str:

        prompt = config.prompt
        system_prompt = config.system_prompt
        messages = config.messages
        temperature = config.temperature
        top_p = config.top_p
        max_tokens = config.max_tokens
        retries = config.retries or 3
        delay = config.delay or 1
        attempt = 0
        response = ""

        # print(messages)
        if messages is None:
            if system_prompt:
                content = f"User: {prompt}"
            else:
                content = prompt
        else:
            content_parts = []
            if messages[0].get("role") == "system":
                system_prompt = messages[0].get("content")
                messages = messages[1:]
            for msg in messages:
                role = msg.get("role", "user")
                msg_content = msg.get("content", "")
                if role == "system":
                    content_parts.append(f"System: {msg_content}")
                elif role == "user":
                    content_parts.append(f"User: {msg_content}")
                elif role == "assistant":
                    content_parts.append(f"Assistant: {msg_content}")
            content = "\n".join(content_parts)

        config_kwargs = {}
        if temperature is not None:
            config_kwargs["temperature"] = temperature
        if top_p is not None:
            config_kwargs["top_p"] = top_p
        if max_tokens is not None:
            config_kwargs["max_output_tokens"] = max_tokens

        # if self.cache is None:
        #     if system_prompt is None:
        #         system_prompt = "You are a helpful assistant."
        #     self.init_cache(system_prompt)
        # print(system_prompt)

        while attempt < retries:
            try:                
                
                response_obj = self.client.models.generate_content(
                    model=self.name,
                    contents=content,
                    # config=generation_config
                    config=types.GenerateContentConfig(
                        # cached_content=self.cache.name,
                        system_instruction=system_prompt,
                        **config_kwargs
                    )
                )
                # print(f'{response_obj.usage_metadata=}')
                logger.info(f"{COLOR_CODES['PURPLE']}Usage: {response_obj.usage_metadata}{RESET}")

                response = response_obj.text
                break
                
            except Exception as e:
                logger.error(f"Error: {COLOR_CODES['RED']}{e}{RESET}")
                attempt += 1
                if attempt < retries:
                    logger.info(f"Retrying in {delay} seconds.")
                    time.sleep(delay)
                else:
                    logger.error(f"All {retries} attempts failed.")
                    raise e
        if not response:
            raise ValueError("No response received from Gemini API")
        return response


def main():
    model = GeminiWrapper(name="gemini-2.5-pro")
    prompt = """
    [{'role': 'system', 'content': '\nBased on the input map JSON, recipes and orders, combined with the following Overcooked multi-agent parallel planning rules, to output a detailed action plan for guiding each agent to complete dish preparation. The action plan must strictly follow the format and constraints.\n\n## 1. Core Principles\nYour planning must always be guided by these three principles:\n- **Maximize Efficiency**: Minimize the total time required to complete all orders. This is the most critical goal.\n- **Maximize Parallelism**: Ensure multiple agents are working simultaneously whenever possible to reduce idle time.\n- **Ensure Accuracy**: Adhere 100% to all action definitions, rules, and constraints outlined below.\n\n## 2. Input Content\n- **Map JSON**: Describes kitchen layout, station coordinates, initial items, and agent positions.\n- **Recipes**: Describes the preparation workflow and required ingredients for the dishes.\n- **Orders**: Describe the dishes that need to be completed in order.\n\n## 3. Output Requirements\n- For each agent, thought about the environment and output a sequence of one or more actions (the number of actions is decided by yourself), then wait for the next observation, and repeat this process until all orders are completed.\n- **DO NOT** try to plan the entire workflow from start to finish in one turn\n- Each action is a dictionary containing action type and parameters. Detailed action definitions are provided in Section 5.\nPlease think step by step and first explain your reasoning process in detail using natural language, including task allocation, key operation sequences, collaboration details, and time arrangement. After the reasoning, output the standard JSON format action without any additional explanations or content.\n\nHere is the output format example:\n\n```json\n{\n    "reasoning": "...",\n    "plan": {\n        "agent1": [\n          {"action": "MoveTo", "target": [x1, y1]},\n          {"action": "Interact", "target": "station_name1"},\n          {"action": "MoveTo", "target": [x2, y2]},\n          {"action": "Process", "target": "station_name2"},\n          ...\n        ],\n        "agent2": [\n          {"action": "MoveTo", "target": [x3, y3]},\n          {"action": "Interact", "target": "station_name3"},\n          {"action": "Wait", "duration": t},\n          ...\n        ],\n        ...\n    }\n}\n```\nYou must strictly follow the above format without any additional explanations or annotations.\n\n## 4. Environment Rules and Constraints\nThis is the most important section. All rules must be strictly followed.\n**Agent Rules**\n- No Collision: Agents do **not** consider collision boxes between each other; their movement paths and positions can overlap at any time.\n- Single Item Hold: An agent can only hold one item at a time (e.g., an ingredient, a plate, a pot). Item exchange must be done via surfaces like tables; direct passing is not allowed. Cannot hold multiple ingredients or containers at once.\n- Positioning: Agents can only stand on empty floor tiles; actions must be performed on adjacent empty ground to target stations; movement can only occur through empty ground. In summary, at any time, an agent\'s coordinates can **never** overlap with a station\'s coordinates.\n- Agents can only interact or process with workstations that are adjacent in the four cardinal directions (up, down, left, right).\n**Environment & Item Rules**\n- Station Exclusivity: Fixed stations like cutting boards or sinks can only be used by one agent at a time for a Process action.\n- Ingredient Dispensing: Ingredients can only be obtained from designated dispensers. Each dispenser provides a specific type of ingredient. All types of ingredients can be directly held without the need for additional containers.\n- Cooking Process:\n  - Stoves can only hold cookware (pots/pans), not ingredients directly.\n  - Cooking starts automatically once cookware is placed on a stove and contains ingredients. Picking it up pauses cooking; placing it back on any stove resumes it.\n  - Cooked food cannot be picked up by hand; it must be transferred in a container.\n- Serving Process:\n  - All food items must be placed on a plate before being submitted at the serving window. The order in which the ingredients are placed on the plate is not important.\n  - Dishes must be served in the exact order specified in the Orders list.\n- Plate Cycle:\n  - Dirty plates return to the dirty plate return station some time after a dish is served.\n  - A dirty plate cannot hold any items and must be washed at a sink to become a clean plate.\n- About time consumption:\n    - Moving to an adjacent tile costs 1 time unit. Total time is proportional to the distance.\n    - Interact: 0 time unit\n    - Chopping: 4 time units\n    - Pot Cooking: 16 time units\n    - Pan Cooking: 24 time units\n    - Washing Plates: 6 time units\n    - Dirty Plate Return: 10 time units\n\n## 5. Action Definitions\n- **MoveTo(coordinate)**:\n  - format: `{"action": "MoveTo", "target": [x, y]}`\n  - Move to the target empty floor coordinate.\n  - Agent can move directly to any reachable empty floor tile in one step, without needing to execute each move step to adjacent tiles. Just calculate the total distance and consume time proportionally.\n  - The path must only go through empty floor tiles.\n  - Important: Agent should directly moves to an empty tile adjacent to the target station, not the station\'s own tile. Always check if the target is empty.\n- **Interact(target_name)**:\n  - format: `{"action": "Interact", "target": "station_name"}`\n  - Interact with an adjacent station. The outcome depends on the agent\'s and station\'s state:\n  - With a regular counter(Table):\n    - If one of hand or table is empty and the other has an item (ingredient/container): Pick up or place down the item.\n    - If both hand and counter hold items:\n      - If one is a container (pot/plate) and the other is an ingredient: Add the ingredient to the container. The container\'s location does not change.\n      - If both are containers: The contents of the held container are transferred to the plate. Both containers remain in their original positions. For example, if holding a pot with rice and interacting with a table with a plate, the rice will be placed into the plate, the pot remains in hand, and the plate remains on the table.\n    - Note: Ingredients already in a plate cannot be moved out; they can only be added to an another plate or discarded to trash.\n  - With an Ingredient Dispenser: \n    - If empty-handed and the top is free, take a raw ingredient from the box. Ingredients can only be taken when empty-handed and there is no item on top of the dispenser.\n    - If holding an item (ingredient or container), agent will put the item down on the top of the dispenser if it\'s free.\n    - Otherwise, follow the same rules as with regular counters.\n  - With a Stove:\n    - Ingredients cannot be placed directly on the stove.\n    - If a cookware is at the stove or in hand, follow the same rules as with regular counters.\n    - Some examples:\n      - If empty-handed and the stove has a pot: Pick up the pot.\n      - If holding a pot and the stove is empty: Place the pot on the stove.\n      - If holding a ingredient and the stove has a pot: Add the ingredient to the pot.\n      - If holding a plate and the stove has a pot: Transfer the pot\'s contents to the plate. The pot remains on the stove, and the plate remains in hand.\n  - With the Serving Window: Submit the completed dish on a plate.\n  - With a Trash Bin: Dispose of the held item or empty the held container.\n  - With the Dirty Plate Return: Items cannot be placed here; only one dirty plate can be picked up at a time with empty hands (if a dirty plate is available).\n  - With a Sink:\n    - If holding a dirty plate: Place it in the sink to be washed (if the sink is free).\n    - If empty-handed: Pick up a clean plate (if one is ready).\n- **Process(target_name)**:\n  - format: `{"action": "Process", "target": "station_name"}`\n  - Perform a continuous action at a station (e.g., chopping, washing).\n  - Note: A stove cannot be the target of a Process action. Cooking operations start automatically when cooking equipment (pots/ pans) containing ingredients is placed on the stove.\n- **Wait(duration)**:\n  - format: `{"action": "Wait", "duration": t}`\n  - Remain idle at the current position for t time units.\n- **Finish()**:\n  - format: `{"action": "Finish"}`\n  - Indicates the agent has completed all its tasks and will take no further actions.\n\n## 6. Suggestions\n- Tasks must be reasonably allocated to achieve multi-agent parallel collaboration and minimize total time consumption.\n- Action sequence must completely cover the entire process from raw material acquisition, processing, assembly to serving.\n- Always notice the timepoint when each action starts and ends to ensure no conflicts in agent actions and get the most efficient plan.\n- You can flexibly decide how many actions to output for each agent in each turn, according to the current situation and planning needs. \n- Do not output too many actions at once if you are not sure about the future situation. You can output less actions and wait for the next observation to adjust your plan.\n\nPlease combine the map layout and recipe workflow to reasonably arrange each operation step and collaboration details, outputting standard actions.\n\nHere is an example of some steps:\n\nTurn 1:\nUser Input:\nMap JSON:\n{\n    "name": "kitchen_salad_8x6",\n    "width": 8,\n    "height": 6,\n    "agents": [\n        {"name": "agent1", "x": 1, "y": 4},\n        {"name": "agent2", "x": 6, "y": 4}\n    ],\n    "tiles": [\n        {"x": 0, "y": 0, "type": "obstacle", "name": "wall"},\n        {"x": 1, "y": 0, "type": "station", "name": "dispenser1", "provides": "lettuce"},\n        {"x": 2, "y": 0, "type": "station", "name": "dispenser2", "provides": "tomato"},\n        {"x": 3, "y": 0, "type": "station", "name": "chopping_board1"},\n        {"x": 4, "y": 0, "type": "station", "name": "chopping_board2"},\n        {"x": 5, "y": 0, "type": "station", "name": "table1", "item": "plate"},\n        {"x": 6, "y": 0, "type": "station", "name": "serving_window"},\n        {"x": 7, "y": 0, "type": "obstacle", "name": "wall"},\n        {"x": 0, "y": 1, "type": "obstacle", "name": "wall"},\n        {"x": 7, "y": 1, "type": "obstacle", "name": "wall"},\n        {"x": 0, "y": 2, "type": "obstacle", "name": "wall"},\n        {"x": 7, "y": 2, "type": "obstacle", "name": "wall"},\n        {"x": 0, "y": 3, "type": "obstacle", "name": "wall"},\n        {"x": 7, "y": 3, "type": "obstacle", "name": "wall"},\n        {"x": 0, "y": 4, "type": "obstacle", "name": "wall"},\n        {"x": 7, "y": 4, "type": "obstacle", "name": "wall"},\n        {"x": 0, "y": 5, "type": "obstacle", "name": "wall"},\n        {"x": 1, "y": 5, "type": "station", "name": "sink"},\n        {"x": 2, "y": 5, "type": "station", "name": "plate_return"},\n        {"x": 3, "y": 5, "type": "station", "name": "table2"},\n        {"x": 4, "y": 5, "type": "station", "name": "table3"},\n        {"x": 5, "y": 5, "type": "station", "name": "table4"},\n        {"x": 6, "y": 5, "type": "station", "name": "table5"},\n        {"x": 7, "y": 5, "type": "obstacle", "name": "wall"}\n    ]\n}\n\nRecipes:\n- salad_advanced: Put chopped lettuce and chopped tomato together to a plate to make a salad.\n\nOrders:\n[salad_advanced]\n\nModel Output:\n```json\n{\n    "reasoning": "The order requires a salad_advanced, which needs chopped lettuce and chopped tomato on a plate. To maximize efficiency and parallelism, I assign agent1 to collect lettuce and agent2 to collect tomato. Agents are not allowed to stand on station tiles, so each agent must move to an empty floor tile adjacent to its assigned dispenser in order to Interact. The lettuce dispenser is located at (1,0), so agent1 should move to the adjacent tile at (1,1) in order to interact with it. Similarly, the tomato dispenser is at (2,0), and agent2 should move to the adjacent tile at (2,1). This allocation ensures each agent is positioned optimally to pick up the correct ingredient, preparing for the chopping step next.",\n    "plan": {\n        "agent1": [\n          {"action": "MoveTo", "target": [1, 1]},\n          {"action": "Interact", "target": "dispenser1"},\n        ],\n        "agent2": [\n          {"action": "MoveTo", "target": [2, 1]},\n          {"action": "Interact", "target": "dispenser2"},\n        ],\n    }\n}\n```\n\nTurn 2:\nUser Input:\nObservation:\nCurrent time: 3\nAgent agent1: vacant (remaining actions: 0)\nAgent agent2: executing {\'action\': \'MoveTo\', \'target\': [2, 1]} (finish at: 7, remaining actions: 1)\n\nCurrent World State:\n{\'width\': 8, \'height\': 6, \'agents\': [{\'name\': \'agent1\', \'x\': 1, \'y\': 1, \'holding\': {\'name\': \'lettuce\', \'state\': \'raw\'}}, {\'name\': \'agent2\', \'x\': 6, \'y\': 4, \'holding\': None}], \'tiles\': [{\'name\': \'wall\', \'type\': \'obstacle\', \'x\': 7, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'dispenser1\', \'type\': \'station\', \'x\': 1, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'dispenser2\', \'type\': \'station\', \'x\': 2, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'chopping_board1\', \'type\': \'station\', \'x\': 3, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'chopping_board2\', \'type\': \'station\', \'x\': 4, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table1\', \'type\': \'station\', \'x\': 5, \'y\': 0, \'item\': {\'name\': \'plate\', \'type\': \'container\', \'contents\': []}, \'in_use\': False, \'current_user\': None}, {\'name\': \'serving_window\', \'type\': \'station\', \'x\': 6, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'sink\', \'type\': \'station\', \'x\': 1, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'plate_return\', \'type\': \'station\', \'x\': 2, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table2\', \'type\': \'station\', \'x\': 3, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table3\', \'type\': \'station\', \'x\': 4, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table4\', \'type\': \'station\', \'x\': 5, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table5\', \'type\': \'station\', \'x\': 6, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}]}\n\nModel Output:\n```json\n{\n    "reasoning": "Current time is 3. Observation shows agent1 is at (1,1) holding raw lettuce, while agent2 is still executing MoveTo to (2,1) and will finish that move at time 7. The chopping stations are at (3,0) and (4,0); agents cannot stand on station tiles, so valid interaction tiles are (3,1) and (4,1). Chopping board 1 is free at this moment. To maximize parallelism and avoid idle time, agent1 should proceed immediately to prepare the lettuce rather than wait for agent2. Concretely, agent1 should MoveTo (3,1) (Manhattan distance 2 → move duration 2, finishing at time 5), then Interact with chopping_board1 to place the raw lettuce on the board, and then start Process on chopping_board1 for 4 units. This sequence occupies chopping_board1 from time 5 to time 9 and will overlap with agent2\'s arrival at the tomato dispenser (finish move at time 7) and subsequent actions, achieving parallel chopping while respecting station exclusivity and the rule that agents must interact from adjacent tiles.",\n    "plan": {\n        "agent1": [\n          {"action": "MoveTo", "target": [3, 1]},\n          {"action": "Interact", "target": "chopping_board1"},\n          {"action": "Process", "target": "chopping_board1"},\n        ],\n    }\n}\n```\n\nTurn 3:\nUser Input:\nObservation:\nCurrent time: 7\nAgent agent1: executing {\'action\': \'Process\', \'target\': \'chopping_board1\'} (finish at: 9, remaining actions: 0)\nAgent agent2: vacant (remaining actions: 0)\n\nCurrent World State:\n{\'width\': 8, \'height\': 6, \'agents\': [{\'name\': \'agent1\', \'x\': 3, \'y\': 1, \'holding\': None}, {\'name\': \'agent2\', \'x\': 2, \'y\': 1, \'holding\': {\'name\': \'tomato\', \'state\': \'raw\'}}], \'tiles\': [{\'name\': \'wall\', \'type\': \'obstacle\', \'x\': 7, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'dispenser1\', \'type\': \'station\', \'x\': 1, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'dispenser2\', \'type\': \'station\', \'x\': 2, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'chopping_board1\', \'type\': \'station\', \'x\': 3, \'y\': 0, \'item\': {\'name\': \'lettuce\', \'state\': \'raw\'}, \'in_use\': True, \'current_user\': \'agent1\'}, {\'name\': \'chopping_board2\', \'type\': \'station\', \'x\': 4, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table1\', \'type\': \'station\', \'x\': 5, \'y\': 0, \'item\': {\'name\': \'plate\', \'type\': \'container\', \'contents\': []}, \'in_use\': False, \'current_user\': None}, {\'name\': \'serving_window\', \'type\': \'station\', \'x\': 6, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'sink\', \'type\': \'station\', \'x\': 1, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'plate_return\', \'type\': \'station\', \'x\': 2, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table2\', \'type\': \'station\', \'x\': 3, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table3\', \'type\': \'station\', \'x\': 4, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table4\', \'type\': \'station\', \'x\': 5, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table5\', \'type\': \'station\', \'x\': 6, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}]}\n\nModel Output:\n```json\n{\n    "reasoning": "Current time is 7. At this point, agent1 is still processing the lettuce on chopping_board1 and will remain occupied until 9, so it cannot take on new actions yet. Agent2 has arrived at (2,1), adjacent to the tomato dispenser at (2,0), and is ready to collect tomato. The tomato then needs to be chopped, and chopping_board2 at (4,0) (accessible from (4,1)) is currently free. To maximize efficiency and parallelism, agent2 should first Interact with the tomato dispenser to pick up raw tomato, then MoveTo (4,1), which is the adjacent floor tile to chopping_board2, and finally Interact with the board to place the tomato and begin the chopping process. This ensures both chopping boards are utilized simultaneously, preventing idle time and aligning with the requirement for salad_advanced.",\n    "plan": {\n        "agent2": [\n          {"action": "MoveTo", "target": [4, 1]},\n          {"action": "Interact", "target": "chopping_board2"},\n          {"action": "Process", "target": "chopping_board2"},\n        ],\n    }\n}\n```\n\nTurn 4:\nUser Input:\nObservation:\nCurrent time: 9\nAgent agent1: vacant (remaining actions: 0)\nAgent agent2: executing {\'action\': \'Process\', \'target\': \'chopping_board2\'} (finish at: 13, remaining actions: 0)\n\nCurrent World State:\n{\'width\': 8, \'height\': 6, \'agents\': [{\'name\': \'agent1\', \'x\': 3, \'y\': 1, \'holding\': None}, {\'name\': \'agent2\', \'x\': 4, \'y\': 1, \'holding\': None}], \'tiles\': [{\'name\': \'wall\', \'type\': \'obstacle\', \'x\': 7, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'dispenser1\', \'type\': \'station\', \'x\': 1, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'dispenser2\', \'type\': \'station\', \'x\': 2, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'chopping_board1\', \'type\': \'station\', \'x\': 3, \'y\': 0, \'item\': {\'name\': \'lettuce\', \'state\': \'chopped\'}, \'in_use\': False, \'current_user\': None}, {\'name\': \'chopping_board2\', \'type\': \'station\', \'x\': 4, \'y\': 0, \'item\': {\'name\': \'tomato\', \'state\': \'raw\'}, \'in_use\': True, \'current_user\': \'agent2\'}, {\'name\': \'table1\', \'type\': \'station\', \'x\': 5, \'y\': 0, \'item\': {\'name\': \'plate\', \'type\': \'container\', \'contents\': []}, \'in_use\': False, \'current_user\': None}, {\'name\': \'serving_window\', \'type\': \'station\', \'x\': 6, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'sink\', \'type\': \'station\', \'x\': 1, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'plate_return\', \'type\': \'station\', \'x\': 2, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table2\', \'type\': \'station\', \'x\': 3, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table3\', \'type\': \'station\', \'x\': 4, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table4\', \'type\': \'station\', \'x\': 5, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table5\', \'type\': \'station\', \'x\': 6, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}]}\n\nModel Output:\n```json\n{\n    "reasoning": "Current time is 9. Agent1 has finished processing the lettuce on chopping_board1 and is currently empty-handed at (3,1). Agent2 is still processing tomato on chopping_board2 and will finish at time 13. To prepare for plating once agent2 finishes, agent1 should first Interact with chopping_board1 to pick up the chopped lettuce. According to the Interact rules, when interacting with a table that already has a plate while holding an ingredient, the ingredient is added to the plate without moving the plate. Therefore, agent1 can then MoveTo (5,1), adjacent to table1 where a plate is available, and Interact with table1 twice: the first Interact places the chopped lettuce onto the plate, the second Interact picks up the plate. Since Interact takes negligible time and agents can stand on the same tile, agent1 can then Wait at (4,1) until agent2 finishes processing the tomato. This sequence ensures that agent1 is ready to combine both ingredients onto the plate immediately after agent2 completes, maximizing parallelism and minimizing total time.",\n    "plan": {\n        "agent1": [\n          {"action": "Interact", "target": "chopping_board1"},\n          {"action": "MoveTo", "target": [5, 1]},\n          {"action": "Interact", "target": "table1"},\n          {"action": "Interact", "target": "table1"},\n          {"action": "MoveTo", "target": [4, 1]},\n          {"action": "Wait", "duration": 1},\n        ],\n    }\n}\n```\n\nTurn 5:\nUser Input:\nObservation:\nCurrent time: 13\nAgent agent1: vacant (remaining actions: 0)\nAgent agent2: vacant (remaining actions: 0)\n\nCurrent World State:\n{\'width\': 8, \'height\': 6, \'agents\': [{\'name\': \'agent1\', \'x\': 4, \'y\': 1, \'holding\': {\'name\': \'plate\', \'type\': \'container\', \'contents\': [{\'name\': \'lettuce\', \'state\': \'chopped\'}]}}, {\'name\': \'agent2\', \'x\': 4, \'y\': 1, \'holding\': None}], \'tiles\': [{\'name\': \'wall\', \'type\': \'obstacle\', \'x\': 7, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'dispenser1\', \'type\': \'station\', \'x\': 1, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'dispenser2\', \'type\': \'station\', \'x\': 2, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'chopping_board1\', \'type\': \'station\', \'x\': 3, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'chopping_board2\', \'type\': \'station\', \'x\': 4, \'y\': 0, \'item\': {\'name\': \'tomato\', \'state\': \'chopped\'}, \'in_use\': False, \'current_user\': None}, {\'name\': \'table1\', \'type\': \'station\', \'x\': 5, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'serving_window\', \'type\': \'station\', \'x\': 6, \'y\': 0, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'sink\', \'type\': \'station\', \'x\': 1, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'plate_return\', \'type\': \'station\', \'x\': 2, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table2\', \'type\': \'station\', \'x\': 3, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table3\', \'type\': \'station\', \'x\': 4, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table4\', \'type\': \'station\', \'x\': 5, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}, {\'name\': \'table5\', \'type\': \'station\', \'x\': 6, \'y\': 5, \'item\': None, \'in_use\': False, \'current_user\': None}]}\n\nModel Output:\n```json\n{\n    "reasoning": "Current time is 13. Agent1 is holding a plate containing chopped lettuce at (4,1). Agent2 has finished processing the tomato and is empty-handed at (4,1). To complete the salad_advanced order, agent1 needs to combine the chopped tomato with the plate containing lettuce and then deliver the completed dish to the serving_window. According to the Interact rules, when interacting with a table that holds an ingredient while holding a plate, the ingredient is added to the plate without moving the plate. Therefore, agent1 only need to Interact with chopping_board2 and can derectly add the chopped tomato to the plate. Then, agent1 should MoveTo (6,1), adjacent to the serving_window, and Interact with the serving_window to submit the completed salad. Finally, agent1 can finish. Agent2 has no further tasks and can directly Finish. This plan ensures that the order is completed efficiently and follows all environment and interaction rules.",\n    "plan": {\n        "agent1": [\n          {"action": "Interact", "target": "chopping_board2"},\n          {"action": "MoveTo", "target": [6, 1]},\n          {"action": "Interact", "target": "serving_window"},\n          {"action": "Finish"}\n        ],\n        "agent2": [\n          {"action": "Finish"}\n        ],\n    }\n}\n```\n'}, {'role': 'user', 'content': '\nMap JSON:\n{\n    "name": "kitchen_salad_8x6",\n    "width": 8,\n    "height": 6,\n    "agents": [\n        {"name": "agent1", "x": 1, "y": 4},\n        {"name": "agent2", "x": 6, "y": 4}\n    ],\n    "tiles": [\n        {"x": 0, "y": 0, "type": "obstacle", "name": "wall"},\n        {"x": 1, "y": 0, "type": "station", "name": "dispenser1", "provides": "lettuce"},\n        {"x": 2, "y": 0, "type": "station", "name": "dispenser2", "provides": "tomato"},\n        {"x": 3, "y": 0, "type": "station", "name": "chopping_board1"},\n        {"x": 4, "y": 0, "type": "station", "name": "chopping_board2"},\n        {"x": 5, "y": 0, "type": "station", "name": "table1", "item": "plate"},\n        {"x": 6, "y": 0, "type": "station", "name": "serving_window"},\n        {"x": 7, "y": 0, "type": "obstacle", "name": "wall"},\n\n        {"x": 0, "y": 1, "type": "obstacle", "name": "wall"},\n        {"x": 7, "y": 1, "type": "obstacle", "name": "wall"},\n\n        {"x": 0, "y": 2, "type": "obstacle", "name": "wall"},\n        {"x": 7, "y": 2, "type": "obstacle", "name": "wall"},\n\n        {"x": 0, "y": 3, "type": "obstacle", "name": "wall"},\n        {"x": 7, "y": 3, "type": "obstacle", "name": "wall"},\n\n        {"x": 0, "y": 4, "type": "obstacle", "name": "wall"},\n        {"x": 7, "y": 4, "type": "obstacle", "name": "wall"},\n\n        {"x": 0, "y": 5, "type": "obstacle", "name": "wall"},\n        {"x": 1, "y": 5, "type": "station", "name": "sink"},\n        {"x": 2, "y": 5, "type": "station", "name": "plate_return"},\n        {"x": 3, "y": 5, "type": "station", "name": "table2"},\n        {"x": 4, "y": 5, "type": "station", "name": "table3"},\n        {"x": 5, "y": 5, "type": "station", "name": "table4"},\n        {"x": 6, "y": 5, "type": "station", "name": "table5"},\n        {"x": 7, "y": 5, "type": "obstacle", "name": "wall"}\n    ]\n}\n\nRecipes:\n- salad_advanced: Put chopped lettuce and chopped tomato together to a plate to make a salad.\n\nOrders:\n[salad_advanced]\n'}, {'role': 'assistant', 'content': '\nReasoning:\n\n**Task Analysis:**\nWe need to prepare a salad that requires chopped lettuce and chopped tomato placed on a plate. Analyzing the map layout, this is an 8x6 kitchen with lettuce dispenser, tomato dispenser, two chopping boards, a table with a plate, and serving window on the top row (y=0), and sink with several empty tables on the bottom row (y=5).\n\n**Initial Agent Positions:**\n- agent1 is at (1,4), closer to the lettuce dispenser\n- agent2 is at (6,4), closer to the tomato dispenser and chopping board 2\n\n**Task Allocation Strategy:**\nBased on the convenience of initial positions, I decided to assign agent1 to handle lettuce processing and final salad assembly/serving, while agent2 handles tomato processing. This avoids conflicts between the two agents in the same area and enables parallel work.\n\n**Detailed Execution Plan:**\n\n**Agent1\'s Task Path:**\n1. Move from (1,4) to (1,1) to approach lettuce dispenser, distance 3, takes 3 time units, current time 3\n2. Interact with dispenser to get lettuce, interaction takes 0 time, current time 3\n3. Move to (3,1) to approach chopping board 1, distance 2, takes 2 time units, current time 5\n4. Place lettuce on chopping board 1, interaction takes 0 time, current time 5\n5. Process lettuce on chopping board 1, takes 4 time units, current time 9\n6. Pick up chopped lettuce, interaction takes 0 time, current time 9\n7. Move to (5,1) to approach table with plate, distance 2, takes 2 time units, current time 11\n8. Place chopped lettuce into the plate on table, interaction takes 0 time, current time 11\n9. Pick up the plate with lettuce, interaction takes 0 time, current time 11\n10. Move to (4,1) to approach chopping board 2, distance 1, takes 1 time unit, current time 12\n11. Wait 1 time unit to ensure agent2 completes tomato chopping, current time 13\n12. Take chopped tomato from chopping board 2 and place into plate, interaction takes 0 time, current time 13\n13. Move to (6,1) to approach serving window, distance 2, takes 2 time units, current time 15\n14. Submit completed salad at serving window, interaction takes 0 time, current time 15\n\n**Agent2\'s Task Path:**\n1. Move from (6,4) to (2,1) to approach tomato dispenser, distance 7, takes 7 time units, current time 7\n2. Interact with dispenser to get tomato, interaction takes 0 time, current time 7\n3. Move to (4,1) to approach chopping board 2, distance 2, takes 2 time units, current time 9\n4. Place tomato on chopping board 2, interaction takes 0 time, current time 9\n5. Process tomato on chopping board 2, takes 4 time units, current time 13\n\n**Time Synchronization and Coordination:**\n- Agent1 completes lettuce chopping at time 9, while agent2 starts tomato chopping at the same time\n- Agent1 reaches chopping board 2 area at time 12, when agent2 is still chopping tomato (will finish at time 13)\n- Agent1 waits 1 time unit until time 13 to ensure agent2 completes tomato chopping\n- This design prevents both agents from competing for the same chopping board and achieves efficient parallel processing\n\n**Optimization Considerations:**\n- Utilizes both chopping boards for parallel processing, avoiding resource conflicts\n- Agent1 handles final salad assembly since it needs to proces
"""
    config = PredictConfig(prompt=prompt, temperature=0.7)
    response = model.predict(config)
    print(response)


if __name__ == "__main__":
    main()